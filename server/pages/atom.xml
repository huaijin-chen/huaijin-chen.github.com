<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>Huaijin的博客</title>
    <link>http://huaijin.info</link>
    <description>My personal blog</description>
    
      <item>
        <title>牛顿法与拟牛顿法（DFP BFGS LBFGS VLBFGS）</title>
        <link>http://huaijin.info/2015/03/23/Newton-QuasiNewton-Method.html</link>
        <guid isPermaLink="true">http://huaijin.info/2015/03/23/Newton-QuasiNewton-Method.html</guid>
        <pubDate>2015-03-23 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;最近做LBFGS的并行，顺便把牛顿法、拟牛顿法顺理一下。&lt;/p&gt;

&lt;p&gt;拟牛顿法是求解非线性优化问题最有效的方法之一。考虑无约束的极小化问题&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=\min\limits_x&amp;space;f(x)&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?\min\limits_x&amp;space;f(x)&quot; title=&quot;\min\limits_x f(x)&quot; /&gt;&lt;/a&gt;，假设&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=f(x)&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?f(x)&quot; title=&quot;f(x)&quot; /&gt;&lt;/a&gt;为凸函数，且二阶连续可导。&lt;/p&gt;

&lt;h3&gt;原始牛顿法&lt;/h3&gt;

&lt;p&gt;基本思想：在现有极小点估计值的附近对f(x)进行二阶泰勒展开，进而找到下一个极小点的估计值&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=x_{k&amp;plus;1}=x_{k}-(H_k)^{-1}g_{k},&amp;space;k=0,1,\cdots&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?x_{k&amp;plus;1}=x_{k}-(H_k)^{-1}g_{k},&amp;space;k=0,1,\cdots&quot; title=&quot;x_{k+1}=x_{k}-(H_k)^{-1}g_{k}, k=0,1,\cdots&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;牛顿法具有二次收敛性，但当目标函数非二次型时，牛顿法不能保证函数稳定地下降（缺点）。&lt;/p&gt;

&lt;h3&gt;阻尼牛顿法&lt;/h3&gt;

&lt;p&gt;每次迭代前需要沿迭代方向&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=d_k=-(H_k)^{-1}g_k&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?d_k=-(H_k)^{-1}g_k&quot; title=&quot;d_k=-(H_k)^{-1}g_k&quot; /&gt;&lt;/a&gt;做线搜索，寻求最优的步长因子&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=\lambda_k&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?\lambda_k&quot; title=&quot;\lambda_k&quot; /&gt;&lt;/a&gt;，即&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=\lambda_k&amp;space;=&amp;space;\arg\min\limits_{\lambda}&amp;space;f(x_k&amp;plus;\lambda&amp;space;d_k)&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?\lambda_k&amp;space;=&amp;space;\arg\min\limits_{\lambda}&amp;space;f(x_k&amp;plus;\lambda&amp;space;d_k)&quot; title=&quot;\lambda_k = \arg\min\limits_{\lambda} f(x_k+\lambda d_k)&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;拟牛顿法&lt;/h3&gt;

&lt;p&gt;基本思想：不使用二阶偏导数而构造出可以近似Hession或Hession的逆的正定对称阵，在“拟牛顿”的条件下优化目标函数。&lt;/p&gt;

&lt;p&gt;先推导拟牛顿条件：在&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=x_{k&amp;plus;1}&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?x_{k&amp;plus;1}&quot; title=&quot;x_{k+1}&quot; /&gt;&lt;/a&gt;附近对&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=f(x)&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?f(x)&quot; title=&quot;f(x)&quot; /&gt;&lt;/a&gt;做泰勒展开，取二阶近似项&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=f(x)=f(x_{k&amp;plus;1})&amp;plus;\nabla&amp;space;f(x_{k&amp;plus;1})(x-x_{k&amp;plus;1})&amp;plus;\frac{1}{2}(x-x_{k&amp;plus;1})^T\nabla^2&amp;space;f(x_{k&amp;plus;1})(x-x_{k&amp;plus;1})&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?f(x)=f(x_{k&amp;plus;1})&amp;plus;\nabla&amp;space;f(x_{k&amp;plus;1})(x-x_{k&amp;plus;1})&amp;plus;\frac{1}{2}(x-x_{k&amp;plus;1})^T\nabla^2&amp;space;f(x_{k&amp;plus;1})(x-x_{k&amp;plus;1})&quot; title=&quot;f(x)=f(x_{k+1})+\nabla f(x_{k+1})(x-x_{k+1})+\frac{1}{2}(x-x_{k+1})^T\nabla^2 f(x_{k+1})(x-x_{k+1})&quot; /&gt;&lt;/a&gt;
推出&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=\nabla&amp;space;f(x)\approx&amp;space;\nabla&amp;space;f(x_{k&amp;plus;1})&amp;plus;H_{k&amp;plus;1}(x-x_{k&amp;plus;1})&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?\nabla&amp;space;f(x)\approx&amp;space;\nabla&amp;space;f(x_{k&amp;plus;1})&amp;plus;H_{k&amp;plus;1}(x-x_{k&amp;plus;1})&quot; title=&quot;\nabla f(x)\approx \nabla f(x_{k+1})+H_{k+1}(x-x_{k+1})&quot; /&gt;&lt;/a&gt;
取&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=x=x_k&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?x=x_k&quot; title=&quot;x=x_k&quot; /&gt;&lt;/a&gt;，推出&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=g_{k&amp;plus;1}-g_{k}\approx&amp;space;H_{k&amp;plus;1}(x_{k&amp;plus;1}-x_k)&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?g_{k&amp;plus;1}-g_{k}\approx&amp;space;H_{k&amp;plus;1}(x_{k&amp;plus;1}-x_k)&quot; title=&quot;g_{k+1}-g_{k}\approx H_{k+1}(x_{k+1}-x_k)&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;引入记号 &lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=s_k=x_{k&amp;plus;1}-x_{k},&amp;space;y_k=g_{k&amp;plus;1}-g_{k}&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?s_k=x_{k&amp;plus;1}-x_{k},&amp;space;y_k=g_{k&amp;plus;1}-g_{k}&quot; title=&quot;s_k=x_{k+1}-x_{k}, y_k=g_{k+1}-g_{k}&quot; /&gt;&lt;/a&gt;， 推出&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=y_k=H_{k&amp;plus;1}s_k&amp;space;,&amp;space;s_k=H^{-1}_{k&amp;plus;1}y_k&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?y_k=H_{k&amp;plus;1}s_k&amp;space;,&amp;space;s_k=H^{-1}_{k&amp;plus;1}y_k&quot; title=&quot;y_k=H_{k+1}s_k , s_k=H^{-1}_{k+1}y_k&quot; /&gt;&lt;/a&gt;(&lt;code&gt;拟牛顿条件&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;它迭代过程中的hession矩阵做约束，因此，对hession对近似的&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=B_{k&amp;plus;1}&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?B_{k&amp;plus;1}&quot; title=&quot;B_{k+1}&quot; /&gt;&lt;/a&gt;，以及对hession的逆做近似的&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=D_{k&amp;plus;1}&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?D_{k&amp;plus;1}&quot; title=&quot;D_{k+1}&quot; /&gt;&lt;/a&gt;，可以将&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=y_{k}=B_{k&amp;plus;1}s_k&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?y_{k}=B_{k&amp;plus;1}s_k&quot; title=&quot;y_{k}=B_{k+1}s_k&quot; /&gt;&lt;/a&gt; 或 &lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=s_{k}=D_{k&amp;plus;1}y_k&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?s_{k}=D_{k&amp;plus;1}y_k&quot; title=&quot;s_{k}=D_{k+1}y_k&quot; /&gt;&lt;/a&gt; 作为指导。&lt;/p&gt;

&lt;h4&gt;DFP算法（Davidon–Fletcher–Powell formula）&lt;/h4&gt;

&lt;p&gt;核心：通过迭代的方法，对hession的逆做近似。迭代格式为&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=D_{k&amp;plus;1}=D_k&amp;plus;\Delta&amp;space;D_k&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?D_{k&amp;plus;1}=D_k&amp;plus;\Delta&amp;space;D_k&quot; title=&quot;D_{k+1}=D_k+\Delta D_k&quot; /&gt;&lt;/a&gt;（通常&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=D_0=I&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?D_0=I&quot; title=&quot;D_0=I&quot; /&gt;&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;猜想&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=\Delta&amp;space;D_k&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?\Delta&amp;space;D_k&quot; title=&quot;\Delta D_k&quot; /&gt;&lt;/a&gt;待定为&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=\Delta&amp;space;D_k=\alpha&amp;space;\mathbf{u}&amp;space;\mathbf{u}^{\mathrm{T}}&amp;plus;\beta\mathbf{v}\mathbf{v}^{\mathrm{T}}&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?\Delta&amp;space;D_k=\alpha&amp;space;\mathbf{u}&amp;space;\mathbf{u}^{\mathrm{T}}&amp;plus;\beta\mathbf{v}\mathbf{v}^{\mathrm{T}}&quot; title=&quot;\Delta D_k=\alpha \mathbf{u} \mathbf{u}^{\mathrm{T}}+\beta\mathbf{v}\mathbf{v}^{\mathrm{T}}&quot; /&gt;&lt;/a&gt;（具有对称性）&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=\Rightarrow&amp;space;s_k=D_ky_k&amp;plus;\alpha\mathbf{u}\mathbf{u}^{\mathrm{T}}y_k&amp;plus;\beta\mathbf{v}\mathbf{v}^{\mathrm{T}}y_k=D_ky_k&amp;plus;(\alpha\mathbf{u}^{\mathrm{T}}y_k)\mathbf{u}&amp;plus;(\beta\mathbf{v}^{\mathrm{T}}y_k)\mathbf{v}&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?\Rightarrow&amp;space;s_k=D_ky_k&amp;plus;\alpha\mathbf{u}\mathbf{u}^{\mathrm{T}}y_k&amp;plus;\beta\mathbf{v}\mathbf{v}^{\mathrm{T}}y_k=D_ky_k&amp;plus;(\alpha\mathbf{u}^{\mathrm{T}}y_k)\mathbf{u}&amp;plus;(\beta\mathbf{v}^{\mathrm{T}}y_k)\mathbf{v}&quot; title=&quot;\Rightarrow s_k=D_ky_k+\alpha\mathbf{u}\mathbf{u}^{\mathrm{T}}y_k+\beta\mathbf{v}\mathbf{v}^{\mathrm{T}}y_k=D_ky_k+(\alpha\mathbf{u}^{\mathrm{T}}y_k)\mathbf{u}+(\beta\mathbf{v}^{\mathrm{T}}y_k)\mathbf{v}&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;括号中是数值，将其分别简单赋值为1，-1，即&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=\alpha=\frac{1}{\mathbf{u}^{\mathrm{T}}y_k},\beta=-\frac{1}{\mathbf{v}^{\mathrm{T}}y_k}&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?\alpha=\frac{1}{\mathbf{u}^{\mathrm{T}}y_k},\beta=-\frac{1}{\mathbf{v}^{\mathrm{T}}y_k}&quot; title=&quot;\alpha=\frac{1}{\mathbf{u}^{\mathrm{T}}y_k},\beta=-\frac{1}{\mathbf{v}^{\mathrm{T}}y_k}&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;其中向量u,v仍有待确定，由上面&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=\Rightarrow&amp;space;\mathbf{u}-\mathbf{v}=s_k-D_ky_k&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?\Rightarrow&amp;space;\mathbf{u}-\mathbf{v}=s_k-D_ky_k&quot; title=&quot;\Rightarrow \mathbf{u}-\mathbf{v}=s_k-D_ky_k&quot; /&gt;&lt;/a&gt;（要此式成立，不妨直接取&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=\mathbf{u}=s_k,\mathbf{v}=D_ky_k&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?\mathbf{u}=s_k,\mathbf{v}=D_ky_k&quot; title=&quot;\mathbf{u}=s_k,\mathbf{v}=D_ky_k&quot; /&gt;&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=\Rightarrow&amp;space;\alpha=\frac{1}{s^{\mathrm{T}}_ky_k},\beta=-\frac{1}{y^{\mathrm{T}}_kD_ky_k}&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?\Rightarrow&amp;space;\alpha=\frac{1}{s^{\mathrm{T}}_ky_k},\beta=-\frac{1}{y^{\mathrm{T}}_kD_ky_k}&quot; title=&quot;\Rightarrow \alpha=\frac{1}{s^{\mathrm{T}}_ky_k},\beta=-\frac{1}{y^{\mathrm{T}}_kD_ky_k}&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;至此，校正矩阵&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=\Delta&amp;space;D_k&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?\Delta&amp;space;D_k&quot; title=&quot;\Delta D_k&quot; /&gt;&lt;/a&gt;就已经构造出来了&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=\Rightarrow&amp;space;\Delta&amp;space;D_k=\frac{s_ks_k^{\mathrm{T}}}{s_k^{\mathrm{T}}y_k}-\frac{D_ky_ky_k^{\mathrm{T}}D_k}{y_k^{\mathrm{T}}D_ky_k}&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?\Rightarrow&amp;space;\Delta&amp;space;D_k=\frac{s_ks_k^{\mathrm{T}}}{s_k^{\mathrm{T}}y_k}-\frac{D_ky_ky_k^{\mathrm{T}}D_k}{y_k^{\mathrm{T}}D_ky_k}&quot; title=&quot;\Rightarrow \Delta D_k=\frac{s_ks_k^{\mathrm{T}}}{s_k^{\mathrm{T}}y_k}-\frac{D_ky_ky_k^{\mathrm{T}}D_k}{y_k^{\mathrm{T}}D_ky_k}&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4&gt;BFGS算法（Broyden–Fletcher–Goldfarb–Shanno algorithm）&lt;/h4&gt;

&lt;p&gt;核心公式的推导过程与DFP完全类似，只是互换了其中s{k}和y{k}的位置。BFGS直接逼近Hession矩阵B_k。(公式敲起来太累了，请自行推导)&lt;/p&gt;

&lt;h4&gt;LBFGS算法(limited-memory BFGS)&lt;/h4&gt;

&lt;p&gt;不再存储完整的D&lt;em&gt;k，而是存储计算过程中的向量序列{s}，{y}。当需要矩阵D&lt;/em&gt;k时，利用向量序列的计算来代替。并且，向量序列也不是全部存储，而是固定存最新的m个。&lt;/p&gt;

&lt;p&gt;若要实现并行，需要同时在x与梯度（影响y的计算）那儿求一致平均。&lt;/p&gt;

&lt;h3&gt;资料&lt;/h3&gt;

&lt;p&gt;【1】&lt;a href=&quot;http://en.wikipedia.org/wiki/Davidon%E2%80%93Fletcher%E2%80%93Powell_formula&quot;&gt;DFP算法&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;【2】&lt;a href=&quot;http://en.wikipedia.org/wiki/Broyden%E2%80%93Fletcher%E2%80%93Goldfarb%E2%80%93Shanno_algorithm&quot;&gt;BFGS算法&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;【3】&lt;a href=&quot;http://en.wikipedia.org/wiki/Limited-memory_BFGS&quot;&gt;LBFGS算法&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;【4】&lt;a href=&quot;http://papers.nips.cc/paper/5333-large-scale-l-bfgs-using-mapreduce.pdf&quot;&gt;Large-scale L-BFGS using MapReduce&lt;/a&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>Mac以及Windows上搭建C++工作环境</title>
        <link>http://huaijin.info/2015/02/13/Cplus-on-MAC.html</link>
        <guid isPermaLink="true">http://huaijin.info/2015/02/13/Cplus-on-MAC.html</guid>
        <pubDate>2015-02-13 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;实验室里我申请的垃圾老爷机被师弟玩坏了，弄了一天，最后发现根本就是硬件损伤，想把它砸掉！太坑了。&lt;/p&gt;

&lt;p&gt;clang是osx自带的c,c++,objective-c编译器；gnu是常用的c++的轻量级编译器，在windows上通常是下载MinGW；sublime就不多说了；本文的目的就是搭建一个轻量级的C++编辑-编译-调试-运行环境。&lt;/p&gt;

&lt;h2&gt;MAC上&lt;/h2&gt;

&lt;h3&gt;方法一：&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;打开sublime，&lt;code&gt;command&lt;/code&gt;+&lt;code&gt;shift&lt;/code&gt;+&lt;code&gt;P&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;输入install，选择&lt;code&gt;install package&lt;/code&gt;，回车&lt;/li&gt;
&lt;li&gt;输入sublimeClang，回车下载&lt;/li&gt;
&lt;li&gt;编写一个简单的c++程序，保存为name.cpp&lt;/li&gt;
&lt;li&gt;在terminal中，&lt;code&gt;clang++ name.cpp -o name&lt;/code&gt;或者&lt;code&gt;g++ name.cpp -o name&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;双击name运行&lt;/li&gt;
&lt;li&gt;如果运行过程不需要输入数据，可以直接在sublime中&lt;code&gt;command&lt;/code&gt;+&lt;code&gt;shift&lt;/code&gt;+&lt;code&gt;B&lt;/code&gt;运行&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;方法二&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;AppStore中下载Xcode&lt;/li&gt;
&lt;li&gt;使用这个IDE&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;WINDOWS上&lt;/h2&gt;

&lt;h3&gt;方法一：&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;安装Installation Manager，运行，选择需要下载的组件，比如这里需要C++有关的组件&lt;/li&gt;
&lt;li&gt;将MinGW的安装路径添加到环境变量中&lt;/li&gt;
&lt;li&gt;cmd中输入&lt;code&gt;g++ -v&lt;/code&gt;来检测gnu是否安装成功&lt;/li&gt;
&lt;li&gt;打开sublime text 3&lt;/li&gt;
&lt;li&gt;&lt;code&gt;preferences&lt;/code&gt;-&amp;gt;&lt;code&gt;browse packages&lt;/code&gt;-&amp;gt;&lt;code&gt;gcc&lt;/code&gt;(好像是这样，反正自己摸索就好了)&lt;/li&gt;
&lt;li&gt;OK，完成&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;方法二：&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Visual Studio&lt;/li&gt;
&lt;li&gt;使用该IDE&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;有用的资料&lt;/h3&gt;

&lt;p&gt;【1】&lt;a href=&quot;https://www.cs.drexel.edu/%7Emcs171/Sp14/extras/g++/index.html&quot;&gt;Writing and Running C++ Programs in the UNIX Environment using g++&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;【2】&lt;a href=&quot;https://www.cs.drexel.edu/%7Emcs171/Sp14/extras/xCode_Instructions/index.html&quot;&gt;Writing and Running C++ Programs in the Mac OS X 10.4 Environment using xCode&lt;/a&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>大数据机器学习初探---南大李武军</title>
        <link>http://huaijin.info/2015/02/04/Group-Meeting.html</link>
        <guid isPermaLink="true">http://huaijin.info/2015/02/04/Group-Meeting.html</guid>
        <pubDate>2015-02-04 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;每周的组会大概会持续2小时。如果是主讲，就需要花更多的时间去准备报告内容。之前，组会开完我就不管了，缺乏总结思考。而这样子的话实质上意义就不大了，没有内化为自己的知识，也没有什么critical thinking。从现在开始，记录每一次组会的思考。&lt;/p&gt;

&lt;p&gt;常言道：亡羊补牢，为时未晚。T.T&lt;/p&gt;

&lt;h3&gt;Outline&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Learning to Hash&lt;/li&gt;
&lt;li&gt;Distributed Learning&lt;/li&gt;
&lt;li&gt;Stochastic Learning&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有一个形象的比喻是这样说的，大数据是金矿，云计算是采矿技术，大数据机器学习是冶金技术。&lt;/p&gt;

&lt;p&gt;大数据机器学习面临的挑战，一是存储，而是计算速度，三是网络。&lt;/p&gt;

&lt;p&gt;哈希学习，在内存、硬盘、cpu、通信上有优势；
分布式学习在内存、硬盘、cpu上有优势，但会增加通信成本；随机学习在内存、硬盘、cpu方面有优势。&lt;/p&gt;

&lt;h3&gt;Learning to Hash&lt;/h3&gt;

&lt;p&gt;主讲人：大师兄&lt;/p&gt;

&lt;p&gt;最近邻搜索在大数据背景下，会出现维数灾难，存储成本也高，查询速度也慢。解决方法之一是保相似性哈希，可以降低维数并减少存储成本。通常用海明距离（hamming distance）来表征哈希值之间的差异。哈希方案也具有较快的查询速度，通常具有常数或者次线性的搜索时间复杂度；即使是穷举搜索也可以被接受，因为海明距离计算起来是很快的。&lt;/p&gt;

&lt;p&gt;哈希函数学习的两个阶段：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Projection Stage（dimension reduction）&lt;/li&gt;
&lt;li&gt;Quantization Stage&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;贡献：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Isotropic Hash&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;思想：学习一个正交阵（幻灯片21页），其目的是让大于某一阈值的feature的重要程度是一样的。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Supervised Hashing with Latent Factor Models&lt;/li&gt;
&lt;li&gt;Supervised Multimodal Hashing with SCM&lt;/li&gt;
&lt;li&gt;Multiple-Bit Quantization&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Distributed Learning&lt;/h3&gt;

&lt;p&gt;主讲人：我&lt;/p&gt;

&lt;p&gt;主要内容：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;文章：Coupled Group Lasso for Web-Scale CTR Prediction&lt;/li&gt;
&lt;li&gt;文章：Distributed Power-Law Graph Computing&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;文章1&lt;/h4&gt;

&lt;p&gt;为了解决在线广告的CTR（click through rate）预测，即当某广告展示给某用户时，它被该用户点击的概率，通常的方法是LR（logistic regression），即逻辑回归。但LR的一个短板是，因其是线性的，所以无法将用户与广告之间某些微妙的非线性关系纳入。注意LR中，正则项若为2范数平方，称为标准逻辑回归；正则项若为1范数，问题通常被叫做Lasso。所以需要一种新的方法。&lt;/p&gt;

&lt;p&gt;这里的贡献是：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;CGL的似然定义中，可以纳入用户与广告之间的某些非线性关系的考量。&lt;/li&gt;
&lt;li&gt;正则项改为参数的2-1范数，目的是是用户特征向量参数W、广告特征向量参数V中更多的行为0，行为0说明该行对应的feature没作用，即达到删除冗余feature的作用。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;分布式实现。这个算法具有较好的扩展性，一个master，若干slave，类似于并行计算，从而实现分布式。&lt;/p&gt;

&lt;h4&gt;文章2&lt;/h4&gt;

&lt;p&gt;GP（graph partitioning）图分割的方法有两种：边分割；点分割。点分割在分布式计算中的通信成本会比图分割小，原因在于在不同的machine上，点分割只需保留点的copy，而边分割需要同时保留点与边的copy。&lt;/p&gt;

&lt;p&gt;切割degree大的点，即邻居多的点可以降低通信成本。&lt;/p&gt;

&lt;h3&gt;Stochastic Learning&lt;/h3&gt;

&lt;p&gt;主讲人：浩锋&lt;/p&gt;

&lt;p&gt;思想：在需要用到所有节点上的信息时，通信代价往往很大，这时可以随机的选取某一个节点上的信息（比如梯度）作为替代品。&lt;/p&gt;

&lt;h3&gt;资料&lt;/h3&gt;

&lt;p&gt;【1】&lt;a href=&quot;http://cs.nju.edu.cn/lwj/slides/BigLearning.pdf&quot;&gt;幻灯片&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;【2】&lt;a href=&quot;http://jmlr.csail.mit.edu/proceedings/papers/v32/yan14.pdf&quot;&gt;Coupled Group Lasso for
Web-Scale CTR Prediction in Display Advertising&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;【3】&lt;a href=&quot;http://papers.nips.cc/paper/5396-distributed-power-law-graph-computing-theoretical-and-empirical-analysis.pdf&quot;&gt;Distributed Power-law Graph Computing:
Theoretical and Empirical Analysis&lt;/a&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>Git常用命令速查表</title>
        <link>http://huaijin.info/2015/01/30/Git-Resources.html</link>
        <guid isPermaLink="true">http://huaijin.info/2015/01/30/Git-Resources.html</guid>
        <pubDate>2015-01-30 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;master: 默认开发分支&lt;/p&gt;

&lt;p&gt;origin: 默认远程版本库&lt;/p&gt;

&lt;p&gt;Head: 默认开发分支&lt;/p&gt;

&lt;p&gt;Head^: Head的父提交&lt;/p&gt;

&lt;h3&gt;创建版本库&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;
$ git clone &amp;lt;url&amp;gt;   #克隆远程版本库
$ git init          #初始化本地版本库
&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;修改和提交&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;
$ git status        #查看状态
$ git diff          #查看变更内容
$ git add .         #跟踪所有改动过的文件
$ git add &amp;lt;file&amp;gt;    #跟踪指定的文件
$ git mv &amp;lt;old&amp;gt;&amp;lt;new&amp;gt; #文件改名
$ git rm&amp;lt;file&amp;gt;      #删除文件
$ git rm --cached&amp;lt;file&amp;gt;            #停止跟踪文件但不删除
$ git commit -m &amp;quot;commit messages&amp;quot;  #提交所有更新过的文件
$ git commit --amend               #修改最后一次改动
&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;查看提交历史&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;
$ git log                    #查看提交历史
$ git log -p &amp;lt;file&amp;gt;          #查看指定文件的提交历史
$ git blame &amp;lt;file&amp;gt;           #以列表方式查看指定文件的提交历史
&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;撤销&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;
$ git reset --hard HEAD      #撤销工作目录中所有未提交文件的修改内容
$ git checkout HEAD &amp;lt;file&amp;gt;   #撤销指定的未提交文件的修改内容
$ git revert &amp;lt;commit&amp;gt;        #撤销指定的提交
$ git log --before=&amp;quot;1 days&amp;quot;  #退回到之前1天的版本 
&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;分支与标签&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;
$ git branch                   #显示所有本地分支
$ git checkout &amp;lt;branch/tag&amp;gt;    #切换到指定分支和标签
$ git branch &amp;lt;new-branch&amp;gt;      #创建新分支
$ git branch -d &amp;lt;branch&amp;gt;       #删除本地分支
$ git tag                      #列出所有本地标签
$ git tag &amp;lt;tagname&amp;gt;            #基于最新提交创建标签
$ git tag -d &amp;lt;tagname&amp;gt;         #删除标签
&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;合并与衍合&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;
$ git merge &amp;lt;branch&amp;gt;        #合并指定分支到当前分支
$ git rebase &amp;lt;branch&amp;gt;       #衍合指定分支到当前分支
&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;远程操作&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;
$ git remote -v                   #查看远程版本库信息
$ git remote show &amp;lt;remote&amp;gt;        #查看指定远程版本库信息
$ git remote add &amp;lt;remote&amp;gt; &amp;lt;url&amp;gt;   #添加远程版本库
$ git fetch &amp;lt;remote&amp;gt;              #从远程库获取代码
$ git pull &amp;lt;remote&amp;gt; &amp;lt;branch&amp;gt;      #下载代码及快速合并
$ git push &amp;lt;remote&amp;gt; &amp;lt;branch&amp;gt;      #上传代码及快速合并
$ git push &amp;lt;remote&amp;gt; :&amp;lt;branch/tag-name&amp;gt;  #删除远程分支或标签
$ git push --tags                       #上传所有标签
&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;资料链接&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://try.github.io/levels/1/challenges/1&quot;&gt;Try Git&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      </item>
    
      <item>
        <title>2015年阅读书单</title>
        <link>http://huaijin.info/2015/01/29/Book-List-2015.html</link>
        <guid isPermaLink="true">http://huaijin.info/2015/01/29/Book-List-2015.html</guid>
        <pubDate>2015-01-29 00:00:00 +0800</pubDate>
        <description></description>
      </item>
    
      <item>
        <title>在Mac上用LaTeX写漂亮的简历</title>
        <link>http://huaijin.info/2014/12/06/Make-resume-by-LaTeX.html</link>
        <guid isPermaLink="true">http://huaijin.info/2014/12/06/Make-resume-by-LaTeX.html</guid>
        <pubDate>2014-12-06 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;img src=&quot;/public/img/posts/resume.jpg&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;

&lt;p&gt;你会搜索查看到这篇文章，相信就不需要我解释为什么要用LaTeX写Resume了：）&lt;/p&gt;

&lt;p&gt;今晚报名Facebook China Tech Talk，最后一步需要上传简历。看着已经2年没有更新过的简历，好捉急。那时真是年轻，不舍得做减法，恨不能一张A4纸写尽一生。于是索性重新制作一份简历。&lt;/p&gt;

&lt;h3&gt;需要准备&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;安装好的LaTeX，如果没有安装请参考&lt;a href=&quot;http://painterlin.com/2014/08/10/Using-LaTeX-with-Sublime-and-Skim-for-Mac.html&quot;&gt;在Mac上通过Sublime、Skim编辑LaTeX&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;互联网&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;资料&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.rpi.edu/dept/arc/training/latex/resumes/&quot;&gt;Using the LaTeX Resume Templates&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.latextemplates.com/cat/curricula-vitae&quot;&gt;LaTeX Templates&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;步骤&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;在上述资料中寻找自己喜欢的模板&lt;/li&gt;
&lt;li&gt;下载模板对应的tex文件&lt;/li&gt;
&lt;li&gt;用LaTeX打开对应文件，编辑，编译&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个时候，如果你使用的是Mac系统，非常不幸，大多数情况下都将编译失败。因为网上多数模板需要使用windows环境下的Tex应用程序，而Mac环境下MacTex应用程序会缺少部分文件。没关系，我们有办法解决。&lt;/p&gt;

&lt;h3&gt;解决方案一：moderncv&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;进入&lt;a href=&quot;http://www.ctan.org/pkg/moderncv&quot;&gt;http://www.ctan.org/pkg/moderncv &lt;/a&gt;下载&lt;code&gt;moderncv package&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;解压，找到模板文件&lt;code&gt;template.tex&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;用已经安装好的LaTeX打开模板文件，编辑，编译，成功&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;但是呢，我个人觉得moderncv模板并不够好，虽然其结构清新简洁，但布局过于稀疏。没关系，我们仍然有办法。感谢一个我无意中发现的网站：ShareLaTeX.com&lt;/p&gt;

&lt;h3&gt;解决方案二：ShareLaTeX.com&lt;/h3&gt;

&lt;p&gt;也许你在上面的资料中找到了你最喜欢的模板，却苦于在Mac OS X系统下无法编译成功。这时可以求助于&lt;a href=&quot;https://www.sharelatex.com/&quot;&gt;ShareLaTeX&lt;/a&gt;，这是一个在线LaTeX编辑网站，并且提供&lt;code&gt;Resume&lt;/code&gt;,&lt;code&gt;Cover Letter&lt;/code&gt;,&lt;code&gt;Journal Article&lt;/code&gt;,&lt;code&gt;Presentation&lt;/code&gt;,&lt;code&gt;Thesis&lt;/code&gt;,&lt;code&gt;Bibliographies&lt;/code&gt;等不同分类的多种模板。最重要的一点事，只需要确定Latex语法无误，再也不需担心什么编译环境、文件缺失等乱七八糟的问题。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;进入&lt;a href=&quot;https://www.sharelatex.com/&quot;&gt;ShareLaTeX&lt;/a&gt;，注册账号&lt;/li&gt;
&lt;li&gt;点击&lt;code&gt;New Project&lt;/code&gt;，选择&lt;code&gt;CV or Resume&lt;/code&gt;，挑选你喜欢的简历模板&lt;/li&gt;
&lt;li&gt;根据自己的情况编辑，自动或手动编译，保存PDF&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;后记&lt;/h3&gt;

&lt;p&gt;既然写到这里了，还想讲讲自己对于简历的体会。但我真的是困得不行了。。。。北京第一次不归夜。。。改天再来补全。。。。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>我的报告 Decentralized Privacy-Preserving Low-Rank Matrix Completion</title>
        <link>http://huaijin.info/2014/11/26/Presentation-at-Chinese-Academy-of-Science.html</link>
        <guid isPermaLink="true">http://huaijin.info/2014/11/26/Presentation-at-Chinese-Academy-of-Science.html</guid>
        <pubDate>2014-11-26 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;img src=&quot;/public/img/posts/s1.png&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;

&lt;h3&gt;我的报告&lt;/h3&gt;

&lt;h4&gt;Section 0: Introduce Myself&lt;/h4&gt;

&lt;p&gt;Page 1&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Good afternoon everyone! My name is Anya Lin. I&amp;#39;m a second-year master candidate from University of Science and Technology of China. It&amp;#39;s my great pleasure to introduce to you the Decentralized Privacy-Preserving Low-Rank Matrix Completion. It&amp;#39;s a joint work with my supervisor, Prof. Ling from USTC.&lt;/li&gt;
&lt;li&gt;Before I start, I want to express my thanks to Prof. Ling for his patient instructions and help over the last a few months.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 2&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Here&amp;#39;s the outline of my presentation.&lt;/li&gt;
&lt;li&gt;First is the introduction.&lt;/li&gt;
&lt;li&gt;And then the centralized matrix completion problem.&lt;/li&gt;
&lt;li&gt;We develop a decentralized algorithm in section 3, and our algorithm is derived from a centralized algorithm as I will talk about in section 2.&lt;/li&gt;
&lt;li&gt;Next, I will introduce the main result of the topology-dependent privacy preservation.&lt;/li&gt;
&lt;li&gt;At last, it&amp;#39;s the conclusion.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Section 1: Introduction&lt;/h4&gt;

&lt;p&gt;Page 3&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;OK， let&amp;#39;s go into the introduction.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 4&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;I&amp;#39;d like to begin with the concept of matrix completion. So what is matrix completion? As we can see in this picture, we have an incomplete matrix, whose entries are known only for a subset of the whole matrix. And the rank of the matrix is very small compared with the size of the matrix.&lt;/li&gt;
&lt;li&gt;The goal of the matrix completion is to recover all these unknown entries of of the matrix, as the right-side picture shows. Here, Z is the recovery of W.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 5&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;There&amp;#39;s many applications of such a problem. Like image processing, recommendation system and so on. Here are 2 examples. The first one is a problem of image processing. The left picture has a lot of noises, or say, only a part of the original picture is known. By using the fact that the original picture is usually low-rank, we can matrix completion to denoise the picture and get a clear version of high quality as the right picture shows.&lt;/li&gt;
&lt;li&gt;The second example is more close to our lives. It&amp;#39;s related to a recommendation system. As you can see, it&amp;#39;s a webpage of Douban Movie. A user sees a movie, such as Interstella, and then scores it on the website. Here we can imagine a huge matrix with rows representing users and columns the movies. This matrix is incomplete and it&amp;#39;s low-rank. Once this matrix is completed, the website can recommend new movies to users.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 6&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Now, here comes a privacy concern. First what is privacy? Privacy is the values one considers private. In the example we mentioned just now, the users&amp;#39; scores of the movies are privacy, because one may not want others to know what movies he has seen or likes. Also, the entries of the matrix could be medical records of patients, or selling data of merchants. These data are considered as privacy.&lt;/li&gt;
&lt;li&gt;Obviously, no one wants the leakage of his privacy.&lt;/li&gt;
&lt;li&gt;However, in reality there may exist a malicious agent, a bad guy. For some reasons you have to give your private data to it, but you don&amp;#39;t know wether you can trust it or not.&lt;/li&gt;
&lt;li&gt;In this situation, we need privacy-preservation. Privacy-preservation is the ability to prevent a malicious agent from obtaining or reconstructing the private data.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Section 2: Centralized Matrix Completion Problem&lt;/h4&gt;

&lt;p&gt;Page 7&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Now let&amp;#39;s go into the centralized matrix completion problem.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 8&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;When we are faced with a low-rank matrix completion problem, the intuitive thought would be to minimize the rank of the matrix, but this is a nonconvex problem. &lt;/li&gt;
&lt;li&gt;Therefore, we insteadly minimize the nuclear-norm the the matrix, since nuclear-norm is the approximation of the rank and it&amp;#39;s convex.&lt;/li&gt;
&lt;li&gt;Another approach is if the rank of matrix is known to be r as a prior theoreticallyor empirically, we can get the matrix factorization formulation. This approach is advantageous over the nuclear-norm approach since the latter one needs sigular value decomposition, which is computationally expensive and even intractable in decentralized computing.&lt;/li&gt;
&lt;li&gt;A centralized algorithm called LMaFit to solve this is as the following steps shows.&lt;/li&gt;
&lt;li&gt;We have to keep in mind that our algorithm is derived from LMaFit.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Section 3: Decentralized Matrix Completion Problem&lt;/h4&gt;

&lt;p&gt;Page 9&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;After the centralized problem, let&amp;#39;s go into the decentralized one.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 10&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;In decentralized computing, we have a network composed of L agents.&lt;/li&gt;
&lt;li&gt;There is an undirected edge between two agents if they can communicate with each other through one hop.&lt;/li&gt;
&lt;li&gt;The goal of all the agents in such a network is to collaboratively complete a low-rank matrix in a decentralized fashion.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 11&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;To be specific, we segment the whole data matrix W into groups of columns. And do the same to Y and Z. Each agent i in the network holds the corresponding Zi, Yi and entries of Wi. &lt;/li&gt;
&lt;li&gt;However, X cannot be segmented and distributed to agents because the update of X contains the summation of ZiYi&amp;#39; over all agents. So we let each agent i holds a local copy X(i) of X.&lt;/li&gt;
&lt;li&gt;After doing this, we get a naive decentralized implementation of LMaFit. At iteration k, each agent i does the following steps respectively.&lt;/li&gt;
&lt;li&gt;Notice that the update of X requires information aggregation of all agents. So here is the challenge: informationaggregationofallagentsisimpossible in real decentralized network unless every agent is connected to all the other agents. &lt;/li&gt;
&lt;li&gt;How to deal with this challenge?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 12&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The answer is dynamic average consensus. Recall that each agent i holds a local copy X(i) of X. If we can make sure that X(i) equals to X for all i, the challenge is solved. &lt;/li&gt;
&lt;li&gt;To do this, we choose c to be 1/L and the update of X becomes the average consensus problem, as we can see in equation (8), X(i) is the average of all the ZiYi&amp;#39;.&lt;/li&gt;
&lt;li&gt;At iteration k,we formulate the average consensus problem as equation (9). The constraint means that instead of letting all the X(i) to be identical we choose to let each X(i) equals to it neighboring X(j).&lt;/li&gt;
&lt;li&gt;A key observation is that exact average consensus at every iteration is not necessary. We use EXTRA to do inexact dynamic average consensus, which saves the computational cost.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 13&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Our decentralized algorithm called D-LMaFit is developed as below.&lt;/li&gt;
&lt;li&gt;Step 1 is the initialization.&lt;/li&gt;
&lt;li&gt;Step 2, use EXTRA to do the inexact average consensus problem.&lt;/li&gt;
&lt;li&gt;Step 3, update Y and X respectively. &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 14&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The performance of D-LMaFit is shown in these two pictures. (Explain what these pictures indicate to the audience)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Section 4: Topology-Dependent Privacy Preservation&lt;/h4&gt;

&lt;p&gt;Page 15&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Now let&amp;#39;s go into the section of the topology-dependent privacy preservation.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 16&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;First compare decentralized algorithm with centralized one.&lt;/li&gt;
&lt;li&gt;Centralized algorithm needs a fusion center to collect global data. What if the fusion center is a malicious agent?&lt;/li&gt;
&lt;li&gt;Oops TT, you&amp;#39;ll lose all your privacy.&lt;/li&gt;
&lt;li&gt;How about the decentralzied algorithm? One important advantage of decentralized algortihm over a centralized is there&amp;#39;s no global data collection, each agent observes part of the raw data and communicates with its neighboring agent(s). It seems safer.&lt;/li&gt;
&lt;li&gt;But things aren&amp;#39;t so lucky in reality. Because the communication of X(i) among the network may lead to information leakage.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 17&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;How does this happen? Suppose in a network as this picture shows, we have a malicious agent M, and M attempts to recover the local data matrices of some other agents through information exchange.&lt;/li&gt;
&lt;li&gt;M is interested in recovering the local data Wi, or equivalently Yi or Zi of a set of agents i∈I.&lt;/li&gt;
&lt;li&gt;When the iteration k is large enough, X(i) will be identical. So if a malicious agent M somehow knows other agents&amp;#39; Yi, it can recover the data Zi of agent i by doing X(M)Yi.&lt;/li&gt;
&lt;li&gt;So our concern is, is there any possibility that the malicious agent M can somehow obtain Yi of agent i, and thus get Zi, which is private.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 18&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Before going to details, consider two simple topologies.&lt;/li&gt;
&lt;li&gt;(Explain the two topologies)&lt;/li&gt;
&lt;li&gt;Under what conditions can not a malicious agent M reconstruct the sensitive information of P and Q ?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 19&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Recall the update of X.&lt;/li&gt;
&lt;li&gt;If you could just take a look at the equation, you can find that if the topology is as in the left picture, M can reconstruct ZiYi&amp;#39; and it may be able to solve Yi so that gets the privacy of P and Q.&lt;/li&gt;
&lt;li&gt;But if the topology is as shown in the right picture. M cannot get the private data of P and Q. Why?&lt;/li&gt;
&lt;li&gt;(Explain with the equation)&lt;/li&gt;
&lt;li&gt;M can solve a series of linear inverse problems and calculate the values of ZiYi&amp;#39;, as what we have said just now.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 20&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Now we get a naive conclusion.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 21&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;So the privacy-preserving problem boils down to the linear inverse problem. First we define some variables as this.&lt;/li&gt;
&lt;li&gt;And further we define A and B.&lt;/li&gt;
&lt;li&gt;Using these definition,the update of X can be represented by (14).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 22&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Rewrite this as a linear time-invariant systems we get (15). In this system, QI selects those row blocks in Q belonging to the agents in I, and BI selects the corresponding columns in B. QIC and BIC selects the other corresponding row blocks and columns which do not belong to the agents in I.&lt;/li&gt;
&lt;li&gt;Our analysis uses the concept of z-transfer matrix of (15). The concept is from modern control theory.&lt;/li&gt;
&lt;li&gt;Obviously, rank(T)=rank(TI TIC), since the latter matrix is just a column rearrangement of the former one. &lt;/li&gt;
&lt;li&gt;Now we are ready to develop our theorem.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 23&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Check the proof of the suffienciency of our theorem, it&amp;#39;s rather straightforward.&lt;/li&gt;
&lt;li&gt;If this condition is satisfired, then M has full knowledge of all the X(i).&lt;/li&gt;
&lt;li&gt;So M can solve a series of linear inverse problems.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 24&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The proof of necessity is a little bit complicated. Here&amp;#39;s the only the simplified version of the proof.&lt;/li&gt;
&lt;li&gt; First we show that to determine a unique sequence of Q􏰇 from V􏰇 , we must have (18).&lt;/li&gt;
&lt;li&gt;Suppose (18) doesn&amp;#39;t hold, then there exists at least one column of TI that is linearly dependent on the other columns of T. Then there exists a Q with that column nonzero, and satisfies TQ=0. This corresponds to a nonzero input in I, but the output V is zero for all time. Thus this nonzero input cannot be recovered. This contradicts with the hypothesis. So (18) must hold.&lt;/li&gt;
&lt;li&gt;(Explain these items)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 25&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;(Explain these items)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Section 5: Conclusion&lt;/h4&gt;

&lt;p&gt;Page 26&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;I&amp;#39;d like to quickly go over the main point of today&amp;#39;s topic.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 27&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;First, we propose a decentralized privacy-preserving algorithm, D-LMaFit, to solve the matrix completion problem.&lt;/li&gt;
&lt;li&gt;We solve dynamic average consensus subproblem inexactly.&lt;/li&gt;
&lt;li&gt;We prove the topology-dependent privacy-preserving theorem. It provides a guideline of designing a privacy-preserving network.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 28&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Still we&amp;#39;ve got work to do in the future. (Read items)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 29&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;I guess that&amp;#39;s it. Thank you all very much for listening. Now if you have any question, please feel free to ask me.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;故事&lt;/h3&gt;

&lt;p&gt;这学期我在中科院数学与系统科学研究院(AMSS)访问。第一次参与这边的讨论班时，我就被惊到了：学生做报告也全程英文，不愧是&lt;a href=&quot;http://lsec.cc.ac.cn/%7Eyyx/chinese/indexc.htm&quot;&gt;袁亚湘&lt;/a&gt;老师的学生。于是，11月25日，我也在这儿完成了自己第一次的英文学术报告。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;报告前3天，我问盛镇醴师兄他们报告前会不会排练，师兄说：“肯定要啊！上次去葡萄牙开会，&lt;a href=&quot;http://www.se.cuhk.edu.hk/people/sqma.html&quot;&gt;马士谦&lt;/a&gt;师兄已经讲得那么好了，都还又自己私下练习了5、6遍。师兄真的可以做到每句话精确到几秒钟！”太荔枝了有木有TT。&lt;/li&gt;
&lt;li&gt;于是我也练习了。果然只有努力了内心才会踏实。在当天的报告中，我不仅不紧张，还在瞅到台下一堆人的专注神情时，心里突然弹幕全开：“哇，这感觉好爽。”&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在记录报告之前，插播一段回忆：
大三暑假，我参加&lt;a href=&quot;http://china.ican-contest.org/index.html&quot;&gt;中国大学生物联网创新创业大赛&lt;/a&gt;，正式比赛前一天系里组织答辩练习，我们组讲得一塌糊涂。那一晚，我和向国菲师兄在实验室通宵改幻灯片，准备发言稿，然后一句一句地练习。中途师兄压力太大又累得不行溜出去躲着抽了根烟，回来被我发现了教育了一顿，嗅觉就是这么灵敏没办法。直到凌晨4点，终于觉得还算满意了，两人躺椅子上睡了会儿，当然我被蚊子咬安逸了。早晨7点，寝室开门，两人各自回去洗澡调整状态。9点，开始比赛。不知道为什么突然想起这个，太，美好了。尽管当时觉得真苦逼。&lt;/p&gt;

&lt;h3&gt;资料&lt;/h3&gt;

&lt;p&gt;【1】&lt;a href=&quot;http://www.zhihu.com/question/24544386/answer/30237316&quot;&gt;有哪些高级的英语表达技巧，让人一听就很地道？&lt;/a&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>凸优化的一些基础算法</title>
        <link>http://huaijin.info/2014/11/10/Basic-Algorithms-of-Convex-Opt.html</link>
        <guid isPermaLink="true">http://huaijin.info/2014/11/10/Basic-Algorithms-of-Convex-Opt.html</guid>
        <pubDate>2014-11-10 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;本文假设读者对凸优化有基本了解，主要归纳一些基础算法，以便查阅。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=\min&amp;space;f(x)&amp;space;\triangleq&amp;space;g(x)&amp;plus;h(x)&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?\min&amp;space;f(x)&amp;space;\triangleq&amp;space;g(x)&amp;plus;h(x)&quot; title=&quot;\min f(x) \triangleq g(x)+h(x)&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;其中，f，g，h都是凸函数，g是光滑项，h是非光滑项。&lt;/p&gt;

&lt;h3&gt;Gradient Descent&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=x^&amp;plus;=x-\alpha\nabla&amp;space;f(x)&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?x^&amp;plus;=x-\alpha\nabla&amp;space;f(x)&quot; title=&quot;x^+=x-\alpha\nabla f(x)&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;Proximal Gradient&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=x^&amp;plus;=prox_{\alpha&amp;space;h}(x-\alpha&amp;space;\nabla&amp;space;g(x))=&amp;space;\arg\min_u&amp;space;h(u)&amp;plus;\frac{1}{2\alpha}||u-x&amp;plus;\alpha&amp;space;\nabla&amp;space;g(x)||&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?x^&amp;plus;=prox_{\alpha&amp;space;h}(x-\alpha&amp;space;\nabla&amp;space;g(x))=&amp;space;\arg\min_u&amp;space;h(u)&amp;plus;\frac{1}{2\alpha}||u-x&amp;plus;\alpha&amp;space;\nabla&amp;space;g(x)||&quot; title=&quot;x^+=prox_{\alpha h}(x-\alpha \nabla g(x))= \arg\min_u h(u)+\frac{1}{2\alpha}||u-x+\alpha \nabla g(x)||&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;Conjugate Gradient&lt;/h3&gt;

&lt;p&gt;是介于最速下降法和牛顿法之间的一个方法，它仅需要利用一阶导数信息，但克服了最速下降法收敛慢的缺点，又避免了牛顿法需要存储和计算Hession并求逆的缺点。它是解决大型线性方程组最有用的方法之一，也是解决大型非线性最优化最有效的算法之一。&lt;/p&gt;

&lt;h3&gt;Newton&lt;/h3&gt;

&lt;p&gt;见&lt;a href=&quot;http://painterlin.com/2015/03/23/Newton-QuasiNewton-Method.html&quot;&gt;牛顿法与拟牛顿法（DFP BFGS LBFGS VLBFGS）&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;Quasi Newton&lt;/h3&gt;

&lt;p&gt;见&lt;a href=&quot;http://painterlin.com/2015/03/23/Newton-QuasiNewton-Method.html&quot;&gt;牛顿法与拟牛顿法（DFP BFGS LBFGS VLBFGS）&lt;/a&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>什么是 P, NP, NP-complete, NP-hard</title>
        <link>http://huaijin.info/2014/11/09/What-is-NP-Hard.html</link>
        <guid isPermaLink="true">http://huaijin.info/2014/11/09/What-is-NP-Hard.html</guid>
        <pubDate>2014-11-09 00:00:00 +0800</pubDate>
        <description>&lt;h3&gt;相关概念&lt;/h3&gt;

&lt;p&gt;NP-hard（non-deterministic polynomial-time hard）&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;P：能在多项式时间内解决&lt;/li&gt;
&lt;li&gt;NP：不能在多项式时间内解决或不确定能不能在多项式时间内解决，但一旦你找到一个解，只需要多项式时间去验证这个解是正确的&lt;/li&gt;
&lt;li&gt;NP-hard：如果一个问题是NP-hard，意味着可以将任意NP问题化约到这个问题。如果可以解这个问题，那么可以轻松地解任意NP问题。&lt;/li&gt;
&lt;li&gt;NPC：NP完全问题，所有NP问题在多项式时间内都能化约（Reducibility）到某一NP问题，这一NP问题就是NPC问题，即解决了此NPC问题，所有NP问题也都解决了。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;资料原文&lt;/h3&gt;

&lt;p&gt;These refer to how long it takes a program to run.  Problems in class P can be solved with algorithms that run in &lt;strong&gt;polynomial time&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Say you have an algorithm that finds the smallest integer in an array.  One way to do this is by iterating over all the integers of the array and keeping track of the smallest number you&amp;#39;ve seen up to that point.  Every time you look at an element, you compare it to the current minimum, and if it&amp;#39;s smaller, you update the minimum.&lt;/p&gt;

&lt;p&gt;How long does this take?  Let&amp;#39;s say there are n elements in the array.  For every element the algorithm has to perform a constant number of operations.  Therefore we can say that the algorithm runs in O(n) time, or that the runtime is a linear function of how many elements are in the array.  So this algorithm runs in &lt;strong&gt;linear time&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;You can also have algorithms that run in &lt;strong&gt;quadratic time&lt;/strong&gt; (O(n^2)), &lt;strong&gt;exponential time&lt;/strong&gt; (O(2^n)), or even &lt;strong&gt;logarithmic time&lt;/strong&gt; (O(log n)).  Binary search (on a balanced tree) runs in logarithmic time because the height of the binary search tree is a logarithmic function of the number of elements in the tree.&lt;/p&gt;

&lt;p&gt;If the running time is some polynomial function of the size of the input, for instance if the algorithm runs in linear time or quadratic time or cubic time, then we say the algorithm runs in &lt;strong&gt;polynomial time&lt;/strong&gt; and the problem it solves is in class &lt;strong&gt;P&lt;/strong&gt;.&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;NP&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;Now there are a lot of programs that don&amp;#39;t (necessarily) run in polynomial time on a regular computer, but do run in polynomial time on a nondeterministic Turing machine.  These programs solve problems in &lt;strong&gt;NP&lt;/strong&gt;, which stands for &lt;strong&gt;nondeterministic polynomial time&lt;/strong&gt;.  A nondeterministic Turing machine can do everything a regular computer can and more. This means all problems in P are also in NP.&lt;/p&gt;

&lt;p&gt;An equivalent way to define NP is by pointing to the problems that can be verified in polynomial time.  This means there is not necessarily a polynomial-time way to find a solution, but once you have a solution it only takes polynomial time to verify that it is correct.&lt;/p&gt;

&lt;p&gt;Some people think P = NP, which means any problem that can be verified in polynomial time can also be solved in polynomial time and vice versa.  If they could prove this, it would revolutionize computer science because people would be able to construct faster algorithms for a lot of important problems.&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;NP-hard&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;What does NP-hard mean?  A lot of times you can solve a problem by reducing it to a different problem.  I can reduce Problem B to Problem A if, given a solution to Problem A, I can easily construct a solution to Problem B.  (In this case, &amp;quot;easily&amp;quot; means &amp;quot;in polynomial time.&amp;quot;)&lt;/p&gt;

&lt;p&gt;If a problem is &lt;strong&gt;NP-hard&lt;/strong&gt;, this means I can reduce any problem in NP to that problem.  This means if I can solve that problem, I can easily solve any problem in NP.  If we could solve an NP-hard problem in polynomial time, this would prove P = NP.&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;NP-complete&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;A problem is &lt;strong&gt;NP-complete&lt;/strong&gt; if the problem is both&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;NP-hard, and&lt;/li&gt;
&lt;li&gt;in NP.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;参考资料&lt;/h3&gt;

&lt;p&gt;【1】&lt;a href=&quot;http://www.quora.com/What-are-P-NP-NP-complete-and-NP-hard&quot;&gt;What are P, NP, NP-complete, and NP-hard?&lt;/a&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>Yosemite OS X 10.10 Matlab 2012a停止工作的解决办法</title>
        <link>http://huaijin.info/2014/10/31/Yosemite-Matlab-Running-Error.html</link>
        <guid isPermaLink="true">http://huaijin.info/2014/10/31/Yosemite-Matlab-Running-Error.html</guid>
        <pubDate>2014-10-31 00:00:00 +0800</pubDate>
        <description>&lt;h3&gt;问题描述&lt;/h3&gt;

&lt;p&gt;OS X 系统更新到Yosemite后，Matlab 2012a就无法运行了。&lt;/p&gt;

&lt;h3&gt;解决步骤&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;进入&lt;a href=&quot;http://xquartz.macosforge.org/landing/&quot;&gt;XQuartz&lt;/a&gt;下载&lt;code&gt;XQuartz-2.7.7.dmg&lt;/code&gt;，并安装更新。&lt;/li&gt;
&lt;li&gt;打开Mac终端，执行命令：&lt;code&gt;
sudo ln -s /opt/X11/ /usr/X11
&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;下载并安装&lt;a href=&quot;http://support.apple.com/kb/DL1572&quot;&gt;Java 6&lt;/a&gt;更新。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;完成✌️&lt;/h3&gt;

&lt;p&gt;OK，现在Matlab就能重新工作了。&lt;/p&gt;

&lt;h3&gt;参考文章&lt;/h3&gt;

&lt;p&gt;[1]&lt;a href=&quot;http://brainsuite.org/quickstart/installation/mac/yosemite/&quot;&gt; running svreg and bdp on yosemite (os x 10.10)&lt;/a&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>Mac安装unrar和rar解压缩工具</title>
        <link>http://huaijin.info/2014/10/07/Mac-Rar-Unrar.html</link>
        <guid isPermaLink="true">http://huaijin.info/2014/10/07/Mac-Rar-Unrar.html</guid>
        <pubDate>2014-10-07 00:00:00 +0800</pubDate>
        <description>&lt;h3&gt;问题描述&lt;/h3&gt;

&lt;p&gt;Mac不能解压rar文件，但实际中会需要这项功能。比如从邮件中的附件时常以rar文件格式传输。&lt;/p&gt;

&lt;h3&gt;步骤&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;进入&lt;a href=&quot;http://www.rarlab.com/download.htm&quot;&gt;rarlab&lt;/a&gt;下载&lt;code&gt;RAR 5.20 beta 1 for Mac OS X&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;打开Mac终端，执行解压缩命令：tar xvfz rarosx-5.2.b1.tar进行解压&lt;/li&gt;
&lt;li&gt;进入刚刚解压的rar目录中，cd downloads/rar&lt;/li&gt;
&lt;li&gt;在rar目录下使用如下命令进行安装&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;
sudo install -c -o$USER unrar /bin
sudo install -c -o$USER rar /bin
&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;解压与压缩&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;
unrar x filename.rar             #解压
rar a archivename.rar filename   #压缩
&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;后记&lt;/h3&gt;

&lt;p&gt;为什么要折腾这个，因为今天收到一份rar格式的文件。
转眼一年了，好快啊。这是要每年送我一个生日蛋糕的节奏吗？如果是的话，这篇博客需要每年更新一次。&lt;/p&gt;

&lt;h4&gt;2013年&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/public/img/birthday/1.jpg&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;

&lt;h4&gt;2014年&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/public/img/birthday/2.jpg&quot; alt=&quot;2&quot;&gt;&lt;/p&gt;

&lt;h3&gt;谢意&lt;/h3&gt;

&lt;p&gt;蒲俊楠童鞋，阿里嘎多~&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>阿里巴巴大数据竞赛回顾与总结</title>
        <link>http://huaijin.info/2014/10/01/Alibaba-Big-Data.html</link>
        <guid isPermaLink="true">http://huaijin.info/2014/10/01/Alibaba-Big-Data.html</guid>
        <pubDate>2014-10-01 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;8个月前，苏宇师兄问我对&lt;a href=&quot;http://102.alibaba.com/competition/addDiscovery/index.htm&quot;&gt;阿里巴巴大数据竞赛&lt;/a&gt;感兴趣吗。正好我选修了&lt;a href=&quot;http://staff.ustc.edu.cn/%7Echeneh/&quot;&gt;陈恩红&lt;/a&gt;老师的《机器学习与数据挖掘》，很好奇这门课在实际中的应用；身为淘宝用户，也好奇我是如何被推荐的。于是和师兄一起参加比赛，加上计算机学院的刘惠民同学，我们组成了名叫&lt;code&gt;Rosemary&lt;/code&gt;三人团队。这次大赛总共有7276支队伍参赛，我们止步于第二赛季。第一赛季排名56；第二赛季排名68。&lt;/p&gt;

&lt;h3&gt;开放数据&lt;/h3&gt;

&lt;table  class=&quot;table table-bordered table-striped table-condensed&quot;&gt;
   &lt;tr&gt;
     &lt;th&gt;字段&lt;/th&gt;
      &lt;th&gt;字段说明&lt;/th&gt;
      &lt;th&gt;提取说明&lt;/th&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;user_id&lt;/td&gt;
      &lt;td&gt;用户标记&lt;/td&gt;
      &lt;td&gt;抽样、字段加密&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;Time&lt;/td&gt;
      &lt;td&gt;行为时间&lt;/td&gt;
      &lt;td&gt;精度到天级别、隐藏年份&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;action_type&lt;/td&gt;
      &lt;td&gt;用户对品牌的行为类型&lt;/td&gt;
      &lt;td&gt;包括点击（0）、购买（1）、加入购物车（2）、收藏（3）四种行为 &lt;/td&gt;
  &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;brand_id&lt;/td&gt;
      &lt;td&gt;品牌数字ID&lt;/td&gt;
      &lt;td&gt;抽样、字段加密&lt;/td&gt;
   &lt;/tr&gt;
&lt;/table&gt;

&lt;h3&gt;比赛任务&lt;/h3&gt;

&lt;p&gt;根据用户4个月在天猫的行为日志，建立用户的品牌偏好，并预测他们在将来一个月内对品牌下商品的购买行为。&lt;/p&gt;

&lt;h3&gt;评估指标&lt;/h3&gt;

&lt;p&gt;大赛最终的比赛成绩排名以F1得分为准。&lt;/p&gt;

&lt;p&gt;准确率：&lt;img src=&quot;http://latex.codecogs.com/gif.latex?Precision=\frac{\sum_i^N&amp;space;hitBrands_i}{\sum_i^N&amp;space;pBrands_i}&quot; title=&quot;Precision=\frac{\sum_i^N hitBrands_i}{\sum_i^N pBrands_i}&quot; /&gt;&lt;/p&gt;

&lt;p&gt;召回率：&lt;img src=&quot;http://latex.codecogs.com/gif.latex?Recall=\frac{\sum_i^M&amp;space;hitBrands_i}{\sum_i^M&amp;space;bBrands_i}&quot; title=&quot;Recall=\frac{\sum_i^M hitBrands_i}{\sum_i^M bBrands_i}&quot; /&gt;&lt;/p&gt;

&lt;p&gt;F1-Score：&lt;img src=&quot;http://latex.codecogs.com/gif.latex?F_1=\frac{2\times&amp;space;P\times&amp;space;R}{P&amp;plus;R}&quot; title=&quot;F_1=\frac{2\times P\times R}{P+R}&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中，&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;N 为参赛队预测的用户数；M 为实际产生成交的用户数量&lt;br&gt;&lt;/li&gt;
&lt;li&gt;pBrandsi为对用户i 预测他(她)会购买的品牌列表个数；bBrandsi为用户i 真实购买的品牌个数 &lt;/li&gt;
&lt;li&gt;hitBrandsi对用户i预测的品牌列表与用户i真实购买的品牌交集的个数&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;解读&lt;code&gt;准确率&lt;/code&gt;、&lt;code&gt;召回率&lt;/code&gt;和&lt;code&gt;F1-Score&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;准确率就是正确预测数目比上预测总数目。召回率就是正确预测数目比上真实总数目。F1-Score是准确率和召回率的调和平均。理论上，准确率与召回率并没有必然的联系；但在实际中，这二者往往此消彼长、相互制约。有研究表明，在不牺牲准确率的情况下，获得一个高召回率是很难的。在赛题环境下举个栗子：&lt;/p&gt;

&lt;table  class=&quot;table table-bordered table-striped table-condensed&quot;&gt;
   &lt;tr&gt;
     &lt;th&gt;我们预测出&lt;/th&gt;
      &lt;th&gt;会有3个人买东西，A买品牌a，B买品牌b，C买P品牌c&lt;/th&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;真实情况是&lt;/td&gt;
      &lt;td&gt;有4个人买了东西，这4个人分别是A，B，C，D，其中A买a和b，B买b，C买b和c，D买a。&lt;/td&gt;
   &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;按照我们的预测，准确率达到了100%，而召回率仅为50%。由此可见，想取得一个较好的F1-Score成绩，需要保证预测的数据尽量hit之外，还要保证预测的数据能够覆盖尽量多的真实数据。具体到比赛中，就需要很好地确定每个被预测的用户可能会买多少个品牌。&lt;/p&gt;

&lt;p&gt;通过对这三个评判标准的分析，我们初步确定了第一赛季所用的策略。&lt;/p&gt;

&lt;h3&gt;第一赛季&lt;/h3&gt;

&lt;p&gt;大致的方案是：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;加权对用户4种行为次数求和，得到简单的用户ID（行）与品牌ID（列）的&lt;code&gt;兴趣度&lt;/code&gt;（值）矩阵。&lt;/li&gt;
&lt;li&gt;统计前4个月平均每个月有多少用户购买超过2个品牌的东西，记为B。&lt;/li&gt;
&lt;li&gt;根据用户前4个月的购买行为，按照&lt;code&gt;购买力&lt;/code&gt;划分用户购买等级。直白解释就是你以前在天猫上平均每个月买了多少次，我就假设你下个月还会买这么多次。&lt;/li&gt;
&lt;li&gt;第一次切分兴趣度矩阵，保留前B行矩阵。&lt;/li&gt;
&lt;li&gt;对每个用户对不同品牌的兴趣度由高到低排序，再根据每个用户的购买力确定对该用户保留前n列的兴趣数据，并预测他会买这n个数据对应的品牌。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当然，在最初的模型建立起来之后，我们还陆续加了一些规则，比如在&lt;code&gt;时间节截止点&lt;/code&gt;(最后N天，N可以根据自己的理解取值)的单独分析。另外，调参数真就是一项体力活。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/img/posts/s1.jpg&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;

&lt;h3&gt;第二赛季&lt;/h3&gt;

&lt;p&gt;（好困，需要去睡觉Zzz···）细节未完待续&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/img/posts/score0.png&quot; alt=&quot;2&quot;&gt;&lt;/p&gt;

&lt;h3&gt;总结&lt;/h3&gt;
</description>
      </item>
    
      <item>
        <title>Linux 4：磁盘与文件系统管理</title>
        <link>http://huaijin.info/2014/09/30/Linux4.html</link>
        <guid isPermaLink="true">http://huaijin.info/2014/09/30/Linux4.html</guid>
        <pubDate>2014-09-30 00:00:00 +0800</pubDate>
        <description>&lt;h3&gt;认识EXT2文件系统&lt;/h3&gt;

&lt;p&gt;每种操作系统能够使用的文件系统并不相同。 举例来说，windows 98以前的微软操作系统主要利用的文件系统是&lt;code&gt;FAT(或FAT16)&lt;/code&gt;，windows 2000以后的版本有所谓的&lt;code&gt;NTFS&lt;/code&gt;文件系统，至于Linux的正统文件系统则为&lt;code&gt;Ext2&lt;/code&gt;(Linux second extended file system, ext2fs)这一个。此外，在默认的情况下，windows操作系统是不会认识Linux的Ext2的。&lt;/p&gt;

&lt;p&gt;那么文件系统是如何运行的呢？这与操作系统的文件数据有关。较新的操作系统的文件数据除了文件实际内容外，通常含有非常多的属性，例如Linux操作系统的文件权限(rwx)与文件属性(拥有者、群组、时间参数等)。 文件系统通常会将这两部份的数据分别存放在不同的区块，权限与属性放置到&lt;code&gt;inode&lt;/code&gt;中，至于实际数据则放置到&lt;code&gt;data block&lt;/code&gt;区块中。 另外，还有一个超级区块(&lt;code&gt;superblock&lt;/code&gt;)会记录整个文件系统的整体信息，包括inode与block的总量、使用量、剩余量等。&lt;/p&gt;

&lt;h3&gt;文件系统的简单操作&lt;/h3&gt;

&lt;h3&gt;磁盘的分割、格式化、检验与挂载&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;磁盘分区： fdisk, partprobe&lt;/li&gt;
&lt;li&gt;磁盘格式化： mkfs, mke2fs&lt;/li&gt;
&lt;li&gt;磁盘检验： fsck, badblocks&lt;/li&gt;
&lt;li&gt;磁盘挂载与卸除： mount, umount&lt;/li&gt;
&lt;li&gt;磁盘参数修订： mknod, e2label, tune2fs, hdparm&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;配置启动挂载&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;启动挂载 /etc/fstab 及 /etc/mtab&lt;/li&gt;
&lt;li&gt;特殊装置 loop 挂载(映象档不刻录就挂载使用)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;内存置换空间(swap)之建置&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;使用实体分割槽建置swap&lt;/li&gt;
&lt;li&gt;使用文件建置swap&lt;/li&gt;
&lt;li&gt;swap使用上的限制&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;文件系统的特殊观察与操作&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;boot sector 与 superblock 的关系&lt;/li&gt;
&lt;li&gt;磁盘空间之浪费问题&lt;/li&gt;
&lt;li&gt;利用 GNU 的 parted 进行分割行为&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;重点回顾&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;基本上 Linux 的正统文件系统为 Ext2 ，该文件系统内的信息主要有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;superblock：记录此 filesystem 的整体信息，包括inode/block的总量、使用量、剩余量， 以及文件系统的格式与相关信息等；&lt;/li&gt;
&lt;li&gt;inode：记录文件的属性，一个文件占用一个inode，同时记录此文件的数据所在的 block 号码；&lt;/li&gt;
&lt;li&gt;block：实际记录文件的内容，若文件太大时，会占用多个 block 。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Ext2 文件系统的数据存取为索引式文件系统(indexed allocation)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;需要碎片整理的原因就是文件写入的 block 太过于离散了，此时文件读取的效能将会变的很差所致。 这个时候可以透过碎片整理将同一个文件所属的 blocks 汇整在一起。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Ext2文件系统主要有：boot sector, superblock, inode bitmap, block bitmap, inode table, data block 等六大部分。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;data block 是用来放置文件内容数据地方，在 Ext2 文件系统中所支持的 block 大小有 1K, 2K 及 4K 三种而已&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;inode 记录文件的属性/权限等数据，其他重要项目为： 每个 inode 大小均固定为 128 bytes； 每个文件都仅会占用一个 inode 而已； 因此文件系统能够创建的文件数量与 inode 的数量有关；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;文件的 block 在记录文件的实际数据，目录的 block 则在记录该目录底下文件名与其 inode 号码的对照表；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;日志式文件系统 (journal) 会多出一块记录区，随时记载文件系统的主要活动，可加快系统复原时间；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Linux 文件系统为添加效能，会让主存储器作为大量的磁盘高速缓存；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实体链接只是多了一个文件名对该 inode 号码的链接而已；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;符号链接就类似Windows的快捷方式功能。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;磁盘的使用必需要经过：分割、格式化与挂载，分别惯用的命令为：fdisk, mkfs, mount三个命令&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;启动自动挂载可参考/etc/fstab之配置，配置完毕务必使用 mount -a 测试语法正确否；&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;参考资料&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://vbird.dic.ksu.edu.tw/linux_basic/0230filesystem.php#harddisk&quot;&gt;鸟哥的Linux私房菜 第八章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      </item>
    
      <item>
        <title>Linux 3：文件与目录管理</title>
        <link>http://huaijin.info/2014/09/19/Linux3.html</link>
        <guid isPermaLink="true">http://huaijin.info/2014/09/19/Linux3.html</guid>
        <pubDate>2014-09-19 00:00:00 +0800</pubDate>
        <description>&lt;h3&gt;目录的相关操作&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;
.         # 代表此层目录
..        # 代表上一层目录
-         # 代表前一个工作目录
~         # 代表『目前使用者身份』所在的家目录
~account  # 代表 account 这个使用者的家目录(account是个帐号名称)
&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在所有目录底下都会存在的两个目录，分别是&lt;code&gt;.&lt;/code&gt;与&lt;code&gt;..&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;根目录的上一层&lt;code&gt;(..)&lt;/code&gt;与根目录自己&lt;code&gt;(.)&lt;/code&gt;是同一个目录&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;几个常见的处理目录的命令&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;cd：变换目录，cd是Change Directory的缩写&lt;/li&gt;
&lt;li&gt;pwd：显示目前的目录，pwd是Print Working Directory的缩写&lt;/li&gt;
&lt;li&gt;mkdir：创建一个新的目录&lt;/li&gt;
&lt;li&gt;rmdir：删除一个空的目录&lt;/li&gt;
&lt;li&gt;mv：移动文件&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;
pwd -P                   # -P：代表显示正确的完整路径，而不是连接路径
mkdir -m xxx             # -m：直接配置文件的权限
mkdir -p test1/test2     # -p：直接将所需要的目录(包含上一级目录)递回创建起来！
PATH=&amp;quot;$PATH&amp;quot;:/root       # 将/root路径加入PATH环境变量中
&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;文件与目录管理&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;文件与目录的检视： ls&lt;/li&gt;
&lt;li&gt;复制、删除与移动： cp, rm, mv&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;
cp -a        # 将文件的所有特性都一起复制过来
cp -p        # 连同文件的属性一起复制过去，而非使用默认属性(备份常用)
cp -r        # 可以复制目录，但是，文件与目录的权限可能会被改变
rm -i        # 互动模式，在删除前会询问使用者是否动作
rm -r        # 连目录下的东西一起删掉，并且不会询问，慎用
mv -f        # force强制移动，如果目标文件已经存在，不会询问而直接覆盖
mv -i        # 若目标文件 (destination) 已经存在时，就会询问是否覆盖
&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;文件内容查询&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;直接检视文件内容： cat, tac, nl （常用）&lt;/li&gt;
&lt;li&gt;可翻页检视： more, less （常用）&lt;/li&gt;
&lt;li&gt;数据撷取： head, tail&lt;/li&gt;
&lt;li&gt;非纯文字档： od&lt;/li&gt;
&lt;li&gt;修改文件时间与建置新档： touch&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;
cat [-AbEnTv] filename # 由第一行开始显示文件内容。-b列出非空白行行号；-n列出所有行号。
tac                    # 从最后一行开始显示文件内容，tac就是cat倒着写！
nl                     # 显示文件内容，顺便输出行号
more                   # 一页一页地显示文件内容
less                   # 与more类似，但可以往前翻页
head [-n number]       # 只看文件头几行，默认是10行，number是自定义行数
tail                   # 只看文件尾几行，文件很大的时候常用
od                     # 以二进制方式读取文件内容
&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;文件与目录的默认权限与隐藏权限&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;文件默认权限：umask&lt;/li&gt;
&lt;li&gt;文件隐藏属性： chattr, lsattr&lt;/li&gt;
&lt;li&gt;文件特殊权限：SUID, SGID, SBIT, 权限配置&lt;/li&gt;
&lt;li&gt;观察文件类型：file&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;
umask           # 后三位数是被拿走的权限分数，比如0022，u没有被拿走权限，g和o被拿走了w权限
umask -S        # 以符号类型来显示权限
umask number    # 配置自己需要的权限
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在默认的情况中，root的umask会拿掉比较多的属性，root的umask默认是&lt;code&gt;022&lt;/code&gt;， 这是基於安全的考量啦～至於一般身份使用者，通常他们的 umask 为&lt;code&gt;002&lt;/code&gt; ，亦即保留同群组的写入权力。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;特殊权限&lt;code&gt;s&lt;/code&gt;和&lt;code&gt;t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Set UID，简称SUID，当s标志在文件拥有者的x项目为SUID，对目录无效&lt;/li&gt;
&lt;li&gt;Set GID，简称SGID，当s标志在群组的x项目为SGID，对目录有效&lt;/li&gt;
&lt;li&gt;Sticky Bit, 简称SBIT，目前只针对目录有效，对於文件已经没有效果了&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;配置SUID,SGID,SBIT权限&lt;/h3&gt;

&lt;p&gt;在原有的权限数字前面加上需要配置的权限数字。
比如&lt;code&gt;755&lt;/code&gt;-&amp;gt;&lt;code&gt;4755&lt;/code&gt; ，就意味着&lt;code&gt;-rwxr-xr-x&lt;/code&gt;变为了&lt;code&gt;-rwsr-xr-x&lt;/code&gt;。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;4 为 SUID&lt;/li&gt;
&lt;li&gt;2 为 SGID&lt;/li&gt;
&lt;li&gt;1 为 SBIT&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;
chmod 4755 filename
chmod u=rwxs,go=x test; ls -l test      # 配置权限为-rws--x--x的模样
chmod g+s,o+t test; ls -l test          # 配置权限为-rws--s--t，即加入SGID,SBIT权限
&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;命令与文件的搜寻&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;命令档名的搜寻：which&lt;/li&gt;
&lt;li&gt;文件档名的搜寻：whereis, locate, find&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;权限与命令的关系&lt;/h3&gt;

&lt;h4&gt;一、让使用者能进入某目录成为『可工作目录』的基本权限为何：&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;可使用的命令：例如 cd 等变换工作目录的命令；&lt;/li&gt;
&lt;li&gt;目录所需权限：使用者对这个目录至少需要具有 x 的权限&lt;/li&gt;
&lt;li&gt;额外需求：如果使用者想要在这个目录内利用 ls 查阅档名，则使用者对此目录还需要 r 的权限。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;二、使用者在某个目录内读取一个文件的基本权限为何？&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;可使用的命令：例如本章谈到的 cat, more, less等等&lt;/li&gt;
&lt;li&gt;目录所需权限：使用者对这个目录至少需要具有 x 权限；&lt;/li&gt;
&lt;li&gt;文件所需权限：使用者对文件至少需要具有 r 的权限才行！&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;三、让使用者可以修改一个文件的基本权限为何？&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;可使用的命令：例如 nano 或未来要介绍的 vi 编辑器等；&lt;/li&gt;
&lt;li&gt;目录所需权限：使用者在该文件所在的目录至少要有 x 权限；&lt;/li&gt;
&lt;li&gt;文件所需权限：使用者对该文件至少要有 r, w 权限&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;四、让一个使用者可以创建一个文件的基本权限为何？&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;目录所需权限：使用者在该目录要具有 w,x 的权限，重点在 w 啦！&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;五、让使用者进入某目录并运行该目录下的某个命令之基本权限为何？&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;目录所需权限：使用者在该目录至少要有 x 的权限；&lt;/li&gt;
&lt;li&gt;文件所需权限：使用者在该文件至少需要有 x 的权限&lt;/li&gt;
&lt;/ul&gt;
</description>
      </item>
    
      <item>
        <title>Linux 2：文件权限与目录配置</title>
        <link>http://huaijin.info/2014/09/17/Linux2.html</link>
        <guid isPermaLink="true">http://huaijin.info/2014/09/17/Linux2.html</guid>
        <pubDate>2014-09-17 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;Linux最优秀的地方之一，就在于它的多用户、多任务环境。Linux一般将文件可存取访问的身份分为3个类别，分别是owner（用户）、group（用户组）、others（其他人），且3种身份都各自有自己的read，write，execute等权限。&lt;/p&gt;

&lt;h3&gt;用户身份与用户组记录的文件&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;
\etc\passwd     #所有系统账号的相关信息
\etc\shadow     #个人的密码
\etc\group      #Linux所有的组名
&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;文件权限概念&lt;/h3&gt;

&lt;p&gt;当屏幕前面出现“Permission deny”的时候，肯定是权限设置错误。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
ls -al          #ls:list，列出所有文件的详细信息
ls -l           #显示文件，属性的第一个字段是文件的权限，共10位，比如-rwxr-xr--，表示owner具有rwx权限，group具有rx权限，others只具有r权限
&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;改变文件属性与权限&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;
chgrp       #改变文件所属用户组，具体句法记得使用 man page 查询
chown -R 用户账号:所在组群 文件名      #改变文件所有者
chmod       #改变文件的权限
&lt;/code&gt;
其中，chmod修改权限的方法有两种，分别是符号法与数字法，数字法中r，w，x的数值分别是4，2，1。&lt;/p&gt;

&lt;p&gt;要开放“目录”（注意不是“文件”）给任何人看，应该至少同时给予r和x权限，但w权限不可随便给予。&lt;/p&gt;

&lt;h3&gt;文件种类与扩展名&lt;/h3&gt;

&lt;p&gt;使用&lt;code&gt;ls -l&lt;/code&gt;查看到的十个字符中，第一个字符为文件的类型：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;-: 普通文件（regular file）&lt;/li&gt;
&lt;li&gt;d: 目录文件（directory）&lt;/li&gt;
&lt;li&gt;l: 连接文件，类似于windows的快捷方式（link）&lt;/li&gt;
&lt;li&gt;b: 块设备文件（block）&lt;/li&gt;
&lt;li&gt;c: 字符设备文件（character）&lt;/li&gt;
&lt;li&gt;s: 套接字（sockets）&lt;/li&gt;
&lt;li&gt;p: 管道（FIFO, pipe）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Linux目录配置标准：FHS&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/public/img/linuxDIRTREE.gif&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;

&lt;p&gt;根据FHS的定义，最好将&lt;code&gt;/var&lt;/code&gt;独立出来，这样至少/var死掉的时候，根目录还活着，还能够进入救援模式。&lt;/p&gt;

&lt;h3&gt;绝对路径与相对路径&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;cd/var/log(absolute)&lt;/li&gt;
&lt;li&gt;cd../var/log(relative)&lt;/li&gt;
&lt;li&gt;.: 代表当前的目录，也可以用./来表示&lt;/li&gt;
&lt;li&gt;..: 代表上一层目录，也可以用../来表示&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;例子&lt;/h3&gt;

&lt;p&gt;将install.log文件复制成为LAYtest.log，并且要给linanya这个人读写权限，可以这样做：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
[root@localhost ~]# cp install.log LAYtest.log     #若复制文件夹，用cp -r
[root@localhost ~]# ls -al LAYtest.log 
-rw-r--r-- 1 root root 62826 9月  17 15:19 LAYtest.log     #虽然完成了复制，但仍然是root的文件
[root@localhost ~]# chown linanya LAYtest.log 
[root@localhost ~]# ls -al LAYtest.log       
-rw-r--r-- 1 linanya root 62826 9月  17 15:19 LAYtest.log  #文件变成linanya的
[root@localhost ~]# 
&lt;/code&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>Markdown输入LaTeX数学公式</title>
        <link>http://huaijin.info/2014/09/16/Markdown-Math.html</link>
        <guid isPermaLink="true">http://huaijin.info/2014/09/16/Markdown-Math.html</guid>
        <pubDate>2014-09-16 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;Markdown是读写性都非常好的轻量文本编辑语言，这个博客以及世界上许多博客的文章都是用其书写的。但是，在写“科研”博客时，难免会需要频繁地输入数学公式，而Markdown本身并不支持数学公式的输入。我曾经想偷懒直接用Markdown的语法去代替LaTeX数学公式，最后页面显示的结果有点儿丑。却一直也没有去修改。直到前天收到了&lt;a href=&quot;http://www.math.ucla.edu/%7Ewotaoyin/&quot;&gt;印卧涛&lt;/a&gt;老师的一封邮件，邮件里所有的数学公式都是用LaTeX代码写的，正规而美观。由此觉得自己做事还是水了点。做事要认真啊亲。&lt;/p&gt;

&lt;p&gt;本文默认我们是会使用LaTeX编辑数学公式的。&lt;/p&gt;

&lt;h3&gt;解决办法：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;将数学公式以图片形式保存，再在Markdown中将其插入。&lt;/li&gt;
&lt;li&gt;或者，使用LaTeX在线编辑器，输入数学公式，获得html代码，将其插入Markdown。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;步骤：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;进入&lt;a href=&quot;http://www.codecogs.com/latex/eqneditor.php&quot;&gt;CodeCogs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;在盒子里书写公式&lt;/li&gt;
&lt;li&gt;在页面下方复制html代码&lt;/li&gt;
&lt;li&gt;将复制的html代码拷贝到Markdown里&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;缺点：&lt;/h3&gt;

&lt;p&gt;Markdown文件的易读性却因此下降了很多。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>Linux 1：登陆与在线求助man page</title>
        <link>http://huaijin.info/2014/09/13/Linux.html</link>
        <guid isPermaLink="true">http://huaijin.info/2014/09/13/Linux.html</guid>
        <pubDate>2014-09-13 00:00:00 +0800</pubDate>
        <description>&lt;h3&gt;查看内核版本&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;
uname -r
&lt;/code&gt;
稳定版本的偶数版，如2.6.x，适合于商业与家用环境使用；开发中版本，如2.5.x，适合开发特殊功能的环境。&lt;/p&gt;

&lt;h3&gt;登陆&lt;/h3&gt;

&lt;p&gt;Mac：（若以root身份登陆，将username改为root）&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
ssh username@IPaddress
&lt;/code&gt;
Linux：(若以root身份登陆，将username删掉）Linux默认root的提示符为#,而一般身份用户的提示符为$。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
su - username
&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;注销Linux&lt;/h3&gt;

&lt;p&gt;注销Linux并不意味着关机，只是用户离开系统。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
exit
&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;基础命令的操作&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;
command [-options] parameter1 parameter2 ···
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
echo $LANG   #显示目前支持的语言
LANG=en_US   #将语言改为英文系
date         #显示日期与实践
cal 10 2014  #显示日历
bc           #计算器
quit         #退出
&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;重要的热键&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;[tab]&lt;/code&gt;：连按两次，具有“命令补全”和“文件补齐”的作用。
&lt;code&gt;[control]+c&lt;/code&gt;：中断目前程序。
&lt;code&gt;[control]+d&lt;/code&gt;：键盘输入结束；直接离开文字界面（相当于`&lt;code&gt;exit&lt;/code&gt;）。&lt;/p&gt;

&lt;h3&gt;在线求助 man page&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;
man command  #command是要查询的命令名称
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;进入man命令后，可按&lt;code&gt;空格&lt;/code&gt;往下翻页，按&lt;code&gt;q&lt;/code&gt;键离开。
在man page中，可以在任何时候输入&lt;code&gt;/keyword&lt;/code&gt;来查询关键字，比如/date.&lt;/p&gt;

&lt;h3&gt;正确的关机方法&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;
who         #查看目前有谁在线
netstat -a  #查看网络的联机状态
ps -aux     #查看后台执行的程序
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;数据同步写入磁盘：为了防止不正常关机导致的内存数据没有来得及写入磁盘，在文字界面输入&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
sync 
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;惯用的关机命令：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
shutdown -h now     #立刻关机
shutdown -h 20:25   #晚上8点25分关机
shutdown -h +10     #过十分钟后关机
shutdown -r now     #立刻重启
shutdown -r +30 ‘The system will be reboot’    #再过30分钟关机，并显示后面的消息给所有在线用户
shutdown -k now ‘The system will be reboot’    #仅发出警告，系统并不会真正关机
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;重启、关机：reboot，halt，poweroff。务必用man去查询一下。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>Linux 0：实际问题</title>
        <link>http://huaijin.info/2014/09/12/Linux-Problems.html</link>
        <guid isPermaLink="true">http://huaijin.info/2014/09/12/Linux-Problems.html</guid>
        <pubDate>2014-09-12 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;管理实验室服务器的大神师兄&lt;a href=&quot;&quot;&gt;苏宇&lt;/a&gt;毕业了，他将管理服务器的工作交给了我——对Linux和服务器管理毫无经验的小菜一枚。前几天师弟&lt;a href=&quot;https://yunpeng.blog.ustc.edu.cn&quot;&gt;段云鹏&lt;/a&gt;的一些机缘巧合的误操作导致服务器核崩溃，我却手足无措，请来&lt;a href=&quot;http://painterliu.com&quot;&gt;刘惠民&lt;/a&gt;童鞋帮着忙活了两晚，也没能复原系统。最后还是让苏神师兄回了学校一趟才解决问题。由此想了两件事：既然答应了负责管理服务器，就不能再以“浪费精力”、“没兴趣”等借口拒绝学习相关技术；人的时间与精力真的很有限，下一次给承诺之前，先想想自己是否花得起这份时间与精力。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://book.douban.com/subject/4889838/&quot;&gt;《鸟哥的Linux私房菜——基础学习篇》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://book.douban.com/subject/2338464/&quot;&gt;《鸟哥的Linux私房菜——服务器架设篇》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本系列文章分为两部分：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;系统学习上面两本书的笔记。&lt;/li&gt;
&lt;li&gt;实际中遇到的问题及解决方案，即本文内容。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;实际问题&lt;/h2&gt;

&lt;h2&gt;1. 建立网络映射&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Mac：&lt;code&gt;Finder&lt;/code&gt;-&amp;gt;&lt;code&gt;前往&lt;/code&gt;-&amp;gt;&lt;code&gt;连接服务器&lt;/code&gt;-&amp;gt;输入&lt;code&gt;smb://IPaddress/samba&lt;/code&gt;-&amp;gt;&lt;code&gt;连接&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Linux：&lt;code&gt;位置&lt;/code&gt;-&amp;gt;&lt;code&gt;连接服务器&lt;/code&gt;-&amp;gt;“服务类型”选择&lt;code&gt;自定义位置&lt;/code&gt;-&amp;gt;输入&lt;code&gt;smb://IPaddress/samba&lt;/code&gt;-&amp;gt;&lt;code&gt;连接&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;2. ssh登陆失败&lt;/h2&gt;

&lt;p&gt;以root身份远程登陆服务器，密码正确，却显示如下警告：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;bash
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that a host key has just been changed.
The fingerprint for the RSA key sent by the remote host is
3a:17:4b:6e:62:e6:94:df:09:78:99:90:51:68:18:62.
Please contact your system administrator.
Add correct host key in /Users/AnyaLin/.ssh/known_hosts to get rid of this message.
Offending RSA key in /Users/AnyaLin/.ssh/known_hosts:4
RSA host key for 222.195.93.129 has changed and you have requested strict checking.
Host key verification failed.
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;解决方法：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;bash
vi ~/.ssh/known_hosts     #选中最后一条登陆记录，双击`d`删除，按“：”进入末行编辑模式，输入“x”，回车
ssh root@222.195.93.129   #再次登陆
The authenticity of host &amp;#39;222.195.93.129 (222.195.93.129)&amp;#39; can&amp;#39;t be established.
RSA key fingerprint is 3a:17:4b:6e:62:e6:94:df:09:78:99:90:51:68:18:62.
Are you sure you want to continue connecting (yes/no)?    #输入yes
&lt;/code&gt;&lt;/p&gt;

&lt;h2&gt;3. tar.gz 文件解压&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;打开终端&lt;/li&gt;
&lt;li&gt;进入需要解压的xxxx.tar.gz文件所在目录&lt;/li&gt;
&lt;li&gt;$ tar xvfz xxxx.tar.gz&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEAD&lt;/p&gt;

&lt;h2&gt;4. 新建文件命令&lt;/h2&gt;

&lt;p&gt;```
touch a.txt&lt;/p&gt;

&lt;h1&gt;```&lt;/h1&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;cc60f2ed32a5f9727a68a2eb7f2f6a8a1eeac51a&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
</description>
      </item>
    
      <item>
        <title>Matlab科研小贴士</title>
        <link>http://huaijin.info/2014/09/11/Matlab-tips.html</link>
        <guid isPermaLink="true">http://huaijin.info/2014/09/11/Matlab-tips.html</guid>
        <pubDate>2014-09-11 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;使用MATLAB运行算法程序时，可能遇到各种各样的报错。比如，为了保护隐私数据，我在分布式矩阵补全算法中加入随机矩阵之后，某项变量在运行几百步之后会出现NaN报错。我只根据算法顺序去分析问题出现的可能原因，并修改程序。感觉并没有很好地利用MATLAB的强大功能去锁定症结所在。幸运的是，&lt;a href=&quot;http://home.ustc.edu.cn/%7Eshiwei00/index.html&quot;&gt;施伟&lt;/a&gt;大师兄当时和我在一起，他非常热心地帮我分析问题，教我以后遇到类似状况应该怎么去分析与思考。和大师兄讨论了半小时，感觉自己收获不少。&lt;/p&gt;

&lt;p&gt;这篇文章会陆续记录下自己使用MATLAB的体会，以及解决问题的一些技巧。&lt;/p&gt;

&lt;h3&gt;Clear&lt;/h3&gt;

&lt;p&gt;运行一段代码前通常需要将工作空间里的已有数据清除掉。只需要在编辑有实际意义的代码之前写下如下代码：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;matlab
clc; clear; close all;
&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;Random Seed&lt;/h3&gt;

&lt;p&gt;为了保证程序在相同环境下运行以便测试某一个或几个改变对于算法的影响，在使用各种random命令时，需要设定固定种子。这样就不会因为每次随机产生的序列不同而影响程序运行结果。设置随机种子的代码如下：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;matlab
%% random seed
%seed=round(5000*rand);       % use this line if you set a random seed
seed=3302;    % use this line if you set a fixed seed. 3302 can be replaced by other numbers.
fprintf(&amp;#39;Seed = %d\n&amp;#39;,seed);  % print the current seed 
if exist(&amp;#39;RandStream&amp;#39;,&amp;#39;file&amp;#39;)
   RandStream.setGlobalStream(RandStream(&amp;#39;mt19937ar&amp;#39;,&amp;#39;seed&amp;#39;,seed));
else
   rand(&amp;#39;state&amp;#39;,seed); 
   randn(&amp;#39;state&amp;#39;,seed^2);
end
&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;NaN&lt;/h3&gt;

&lt;p&gt;NaN是Not a Number的缩写。当某变量显示NaN时，表示该变量是不明确的数值结果。比如0/0、inf/inf等运算会出现NaN报错。遇到这种情况，首先判断NaN出现在哪一步：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;matlab
if isnan(norres)    %括号里是变量名。判断norres是否为NaN，若是，则在该步暂停程序。
    keyboard;
end
&lt;/code&gt;
再在命令窗里单独查看与该变量有关的其他变量，从而排除正常变量，获知究竟是哪个或哪几个变量出了问题，变为无穷大或无穷小。再检查与这些变量有关的算法。&lt;/p&gt;

&lt;h3&gt;SaveAs&lt;/h3&gt;

&lt;p&gt;若需要比较各参数对算法性能的影响，通常是在程序中修改参数运行，得到算法收敛精度与迭代次数的曲线图。再根据曲线图反向思考修改哪些参数有效。这个过程需要保存产生的大量图片。可以使用&lt;code&gt;hold on&lt;/code&gt;命令将所有虚线画在同一张图上，也可以使用&lt;code&gt;saveas&lt;/code&gt;将所有图片自动保存。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;matlab
%% plot
figure(1)
semilogy(1:iter,y_axis(1:iter),&amp;#39;b-&amp;#39;);  %b：蓝色。－：线段形状
set(gca,&amp;#39;fontsize&amp;#39;,12);
grid on;
xlabel(&amp;#39;\fontsize{12}\it Iteration&amp;#39;); ylabel(&amp;#39;\fontsize{12}\it Normalized residual&amp;#39;);
legend(&amp;#39;\fontsize{12}\it text&amp;#39;);       %text：这条蓝色代表什么
hold on
saveas(gcf,&amp;#39;filename&amp;#39;,&amp;#39;fig&amp;#39;)           %filename：将图片保存为这个名字。fig：保存为fig格式
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;保存变量数据的命令：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
save(&amp;#39;filename&amp;#39;)
save(&amp;#39;filename&amp;#39;,&amp;#39;variables&amp;#39;)
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;注意，在使用&lt;code&gt;hold on&lt;/code&gt;命令时，应该保留上次程序运行后产生的各种数据。即不能在程序中写类似与&lt;code&gt;clear all&lt;/code&gt;之类的清除语句，否则上次曲线图也将被删除。&lt;/p&gt;

&lt;h3&gt;矩阵规范化&lt;/h3&gt;

&lt;p&gt;已知满秩矩阵A，进行下面操作使其所有奇异值均为1。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;matlab
[u s v]=svd(A);
A=u*v&amp;#39;;
&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;安装CVX&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;将cvx压缩包解压&lt;/li&gt;
&lt;li&gt;将cvx文件夹拷贝至如D:\MATLAB Programs\Compressed Sensing目录下&lt;/li&gt;
&lt;li&gt;在Current Folder窗口中打开cvx文件夹&lt;/li&gt;
&lt;li&gt;在Command Window中输入cvx_setup&lt;/li&gt;
&lt;li&gt;在MATLAB的File菜单下的set path把此路径加上。&lt;/li&gt;
&lt;li&gt;把路径加进去后在file→Preferences→General的Toolbox Path Caching里点击update Toolbox Path Cache更新一下&lt;/li&gt;
&lt;li&gt;完成&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;%%分段运行程序&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;选中%%分段&lt;/li&gt;
&lt;li&gt;右键选择&lt;code&gt;evaluate current section&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      </item>
    
      <item>
        <title>动态一致平均问题算法-EXTRA和DAC</title>
        <link>http://huaijin.info/2014/08/31/Papers-about-average-consensus.html</link>
        <guid isPermaLink="true">http://huaijin.info/2014/08/31/Papers-about-average-consensus.html</guid>
        <pubDate>2014-08-31 00:00:00 +0800</pubDate>
        <description>&lt;h3&gt;EXTRA&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=x_{(i)}^1=\sum_{j&amp;space;=&amp;space;1}^Nw_{ij}x_{(j)}^0-\alpha&amp;space;\nabla&amp;space;f_i(x_{(i)}^0)\\&amp;space;\\&amp;space;\\&amp;space;x_{(i)}^{k&amp;plus;2}=x_{(i)}^{k&amp;plus;1}&amp;plus;\sum_{j=1}^Nw_{ij}x_{(j)}^{k&amp;plus;1}-\sum_{j=1}^N\tilde{w}_{ij}x_{(j)}^k-\alpha[\nabla&amp;space;f_i(x_{(i)}^{k&amp;plus;1})-\nabla&amp;space;f_i(x_{(i)}^{k})]&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?x_{(i)}^1=\sum_{j&amp;space;=&amp;space;1}^Nw_{ij}x_{(j)}^0-\alpha&amp;space;\nabla&amp;space;f_i(x_{(i)}^0)\\&amp;space;\\&amp;space;\\&amp;space;x_{(i)}^{k&amp;plus;2}=x_{(i)}^{k&amp;plus;1}&amp;plus;\sum_{j=1}^Nw_{ij}x_{(j)}^{k&amp;plus;1}-\sum_{j=1}^N\tilde{w}_{ij}x_{(j)}^k-\alpha[\nabla&amp;space;f_i(x_{(i)}^{k&amp;plus;1})-\nabla&amp;space;f_i(x_{(i)}^{k})]&quot; title=&quot;x_{(i)}^1=\sum_{j = 1}^Nw_{ij}x_{(j)}^0-\alpha \nabla f_i(x_{(i)}^0)\\ \\ \\ x_{(i)}^{k+2}=x_{(i)}^{k+1}+\sum_{j=1}^Nw_{ij}x_{(j)}^{k+1}-\sum_{j=1}^N\tilde{w}_{ij}x_{(j)}^k-\alpha[\nabla f_i(x_{(i)}^{k+1})-\nabla f_i(x_{(i)}^{k})]&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;DAC&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=x_i(t&amp;plus;1)=x_i(t)&amp;plus;\sum_{j&amp;space;\neq&amp;space;i}a_{ij}(t)(x_i(t)-x_i(t))&amp;plus;r_i(t)-r_i(t-1)&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?x_i(t&amp;plus;1)=x_i(t)&amp;plus;\sum_{j&amp;space;\neq&amp;space;i}a_{ij}(t)(x_j(t)-x_i(t))&amp;plus;r_i(t)-r_i(t-1)&quot; title=&quot;x_i(t+1)=x_i(t)+\sum_{j \neq i}a_{ij}(t)(x_i(t)-x_i(t))+r_i(t)-r_i(t-1)&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;优缺点比较&lt;/h3&gt;

&lt;p&gt;其中，DAC最大的缺点在于第一次迭代时对于r(-1)时刻的依赖，在实际仿真中，如果需要对动态输入求一致平均，往往并不能获取输入在-1时刻的值。导致在矩阵补全问题中，DAC做不精确的动态一致平均的子问题效果并不好。&lt;/p&gt;

&lt;p&gt;而EXTRA却有很好的效果。&lt;/p&gt;
</description>
      </item>
    
  </channel>
</rss>